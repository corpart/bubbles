<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<title>bubbles</title>
<style>
html, body/*, #graph */{
    width: 800px;
    height: 600px;
}
.button{
   
}

svg{
    position:absolute;
    width: 800px;
    height: 900px;
    left : 0px ;
    top: 0px;
}
</style>
</head>

<body>
 

<script src="build/three.js"></script>    
<script src="js/renderers/Projector.js"></script>
<script src="js/renderers/CanvasRenderer.js"></script>
<script src="js/libs/stats.min.js"></script>

<script src="js/libs/d3.min.js"></script>    
<!-- <script src="js/viz.js"></script> -->


<script>

    var SEPARATION = 100, AMOUNTX = 20, AMOUNTY = 20;

    var container, stats;
    var camera, scene, renderer;

    var particles, particle; //, count = 0;
    var lines; 

    var showDataLinksInLines = false; 


    var mouseX = 0, mouseY = 0;

    var windowHalfX = window.innerWidth / 2;
    var windowHalfY = window.innerHeight / 2;

    var data
    var isDataReady = false; 
    
    var particleMaterial
    var lineMaterial

    var simulation

    var buttons 

    var svg 

    var colors 
  
    var PI2 = Math.PI * 2;

    var THREEcenterShiftX = -300;
    var THREEcenterShiftY = -10 ;



    init();
    animate();

    function init() {

        container = document.createElement( 'div' );
        container.setAttribute("z-index", 1);


        document.body.appendChild( container );

        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
        camera.position.z = 1000;

        scene = new THREE.Scene();

        particles = new Array();
        lines = new Array();    

        lineMaterial = new THREE.LineBasicMaterial({
            color: 0X666666//0xaaaaaa
        });

        colors = [
                 "#53777A",  
                 "#542437",
                 "#C02942",
                 "#D95B43",
                 "#ECD078",
                 "#A8DBA8",  
                 "#79BD9A",
                 "#3B8686",
                 "#0B486B"
                ];

      
        drawBackground();
        //load data from json  
        d3.json("data/data.json", function(error, dataset){
                if (error) {
                    console.log(error);
                }else{
                    isDataReady = true; 
                    data = dataset ;
                    prep(data);
                       
                }
        });
         
        drawForeground();
        ///THREEJS 
        renderer = new THREE.CanvasRenderer();
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );

        stats = new Stats();
        container.appendChild( stats.dom );

        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        document.addEventListener( 'touchstart', onDocumentTouchStart, false );
        document.addEventListener( 'touchmove', onDocumentTouchMove, false );

        //

        window.addEventListener( 'resize', onWindowResize, false );

    }

    function spriteMaterial( r, groupID ){
      
        return  new THREE.SpriteCanvasMaterial( {
            color: colors[groupID], 
            program: function ( context ) {
                context.beginPath();
                context.arc( 0, 0, r, 0, PI2, true );
                context.fill();
            }
        } );

    }

    function prep(data){
  
       
        for (var i =0; i < data.nodes.length; i++){          
            particle = particles[ i ] = new THREE.Sprite( spriteMaterial( data.nodes[i].r , data.nodes[i].group ));
            particle.position.x = ~~d3.randomUniform(-300, 300)()//data.nodes[i].x;
            particle.position.y = ~~d3.randomUniform(-300, 300)(); //data.nodes[i].y;
            particle.position.z = ~~d3.randomUniform(-300, 300)();
            scene.add( particle );           
            // console.log("initializing THREE particles"); 
            // console.log(i+" "+ data.nodes[i].x+ " " + data.nodes[i].y);
            // console.log(i+" "+ particle.position.x + " " + particle.position.y );
        }
        
        data.links.forEach(function(d){
           addLineBetweenTwoParticles(d.source, d.target);
        })
          
        //add triangle
        var geom = new THREE.Geometry();
        var v1 = new THREE.Vector3(0,0,0);
        var v2 = new THREE.Vector3(300,0,0);
        var v3 = new THREE.Vector3(300,300,100);
        
        geom.vertices.push(v1);
        geom.vertices.push(v2);
        geom.vertices.push(v3);
     
        geom.faces.push( new THREE.Face3( 0, 1, 2) );
        geom.computeFaceNormals();

        var mashMaterial = new THREE.MeshStandardMaterial( {
                    color: 0xaa0000,
                    opacity: .25,
                    transparent: true,
                    blending: THREE.AdditiveBlending 

                } );

        var mesh= new THREE.Mesh( geom, mashMaterial );
        scene.add(mesh)


        simulation = d3.forceSimulation()
            .force("link", d3.forceLink()
                .id(function(d) { return d.index })
                .distance(function(d){return d.value})
                .strength(0.3)
                // .strength(function(d){
                //     return .1/d.value 
                // })
                )

            .force("collide",d3.forceCollide( function(d){  return d.r + 40 }).iterations(5) ) //2//16
            .force("charge", d3.forceManyBody(0)
                .strength(-30)  //negative:repell 
                .distanceMax(20)
                )
            .force("center", d3.forceCenter(windowHalfX / 2 + THREEcenterShiftX, windowHalfY / 2 + THREEcenterShiftY)) // keeps nodes in the center of the viewport
            .force("y", d3.forceY(0))
            .force("x", d3.forceX(0).strength(0.05))

        // var ticked = function() { ///TODO function?
        // }  

        simulation
            .velocityDecay(0.6) //default 0.4
            .alphaTarget(0.1) //defaualt 0
            .nodes(data.nodes)
            // .on("tick", ticked) //updates are handled by the THREE render function 
            .force("link")
            .links(data.links);

        
    }

    function addLineBetweenTwoParticles(sourceInd,targetInd){

        //make sure indexes are in range
        if (sourceInd < particles.length && targetInd < particles.length){
            var newLineIndex = lines.length; 
            var geometryLine = new THREE.Geometry()
            var t = particles[targetInd];
            var s = particles[sourceInd];
            geometryLine.vertices.push(
                new THREE.Vector3( t.position.x, t.position.y, t.position.z ),
                new THREE.Vector3( s.position.x, s.position.y, s.position.z )
            );

            var lineTemp = lines[newLineIndex] = new THREE.Line(geometryLine, lineMaterial)

            if (showDataLinksInLines ){
                scene.add(lineTemp);
            }
            
        
        //    console.log("line " + newLineIndex + " added between " + sourceInd + " & " + targetInd) ; 
        }
      
    }


    function onWindowResize() {

        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    //

    function onDocumentMouseMove( event ) {

        mouseX = event.clientX - windowHalfX;
        mouseY = event.clientY - windowHalfY;

    }

    function onDocumentTouchStart( event ) {

        if ( event.touches.length === 1 ) {

            event.preventDefault();

            mouseX = event.touches[ 0 ].pageX - windowHalfX;
            mouseY = event.touches[ 0 ].pageY - windowHalfY;

        }

    }

    function onDocumentTouchMove( event ) {

        if ( event.touches.length === 1 ) {

            event.preventDefault();

            mouseX = event.touches[ 0 ].pageX - windowHalfX;
            mouseY = event.touches[ 0 ].pageY - windowHalfY;

        }

    }

    function pushBubble(bx, by, br, bi){
           
            var newNodeID = data.nodes.length; 
             
            //find other nodes within the same group 
            //do this before adding itself to avoiding linking to self
            var sameGroup = data.nodes.filter ( 
                    function(d){ 
                        return +d.group == bi; 
                    } // +turn string to number
                )

            data.nodes.push({
                id:  newNodeID, 
                r: br, 
                x: bx,
                y: by,
                group:  bi });


            
            var particle = particles[ newNodeID ] = new THREE.Sprite( spriteMaterial( br , bi ) ); 
            particle.position.x = bx;
            particle.position.y = by; 
            particle.position.z = ~~d3.randomUniform(-70, 70)();
            scene.add( particle );       
            // debugger

            
            if (sameGroup.length>0){
                //add first link 
                var j = ~~d3.randomUniform(0, sameGroup.length)(); 
                var targetInd = sameGroup[j].id; 
                data.links.push ({source: newNodeID , 
                    target: targetInd, 
                    value:~~d3.randomUniform(1, 10)()
                })
                addLineBetweenTwoParticles(newNodeID, targetInd)

                //add second link
                var k = ~~d3.randomUniform(0, sameGroup.length)(); 
                if ( k!=j){
                    targetInd = sameGroup[k].id; 
                    data.links.push ({source: newNodeID , target: targetInd, value:~~d3.randomUniform(1, 5 )() })
                    addLineBetweenTwoParticles(newNodeID, targetInd)
                   
                }
 


            }

            
            restart(data);
        }




        function restart(data) {
          
          // // Apply the general update pattern to the nodes.
          //   node = node.data(data.nodes, function(d) { return d.id;});
          //   node.exit().remove();
          //   node = node.enter().append("circle")
          //       .attr("r", function(d){  return d.r })
          //       .attr("fill", function(d) { return color(d.group); })
          //       // .attr("fill", function(d) { return color(~~d3.randomUniform(20)()); })
          //       .merge(node);
    
          // // Apply the general update pattern to the links.
          //   link = link.data(data.links, function(d) { return d.source.id + "-" + d.target.id; });
          //   link.exit().remove();
          //   link = link.enter().append("line").merge(link);

          // Update and restart the simulation.
            simulation.nodes(data.nodes);
            simulation.force("link").links(data.links);
            // simulation.alpha(1).restart();
        }



    function drawForeground(){
         svg = d3.select('body').append('svg')
        
         d3.json("data/buttons.json", function(error, dataset){
             
                if (error) {
                    console.log(error);
                }else{
                    
                    buttons = svg
                        .selectAll("polygon")
                        .data(dataset.buttons)
                        .enter()
                        .append("polygon")
                        .attr("class", "button")
                        .attr("x3", function(d){ return d.x3;}) //approximate location in threejs space 
                        .attr("y3", function(d){ return d.y3;})
                        .attr("id", function(d){ return d.id;}  )
                        .attr("transform", function(d){
                             // "translate(480,480)scale(23)rotate(180)"
                             var s = "translate("
                              s +=d.x               //location in html space
                              s +=","
                              s +=d.y
                              s +=")scale(0.5)"
                             return s

                        })
                        .attr("points", function(d){
                            // console.log(d.poly)
                            return d.poly;
                        })
                        .attr("fill", function (d,i){ return colors[i]; })
                        // .attr("radius",10)
                        ;        


                     d3.selectAll(".button")
                        .on("mousedown", function(){
                            console.log("mousedown on button: " + d3.select(this).attr("id") );
                            //record time 
                            // d3.select(this).attr("touchStartTime") = new Date().getTime();  
                            
                        })
                        .on("mouseup", function() {
                        //function pushBubble(bx, by, br, bi){
                        pushBubble(
                            +d3.select(this).attr("x3"), //turn string to int 
                            +d3.select(this).attr("y3"), 
                            ~~d3.randomUniform(5,30)(), 
                            d3.select(this).attr("id"));
                    })
                       
                }
        });



    }



    function drawBackground(){
           /////base wall
        var material = new THREE.SpriteCanvasMaterial( { 
            color: 0xffffff,
            program: function ( context ) {
                context.beginPath();
                context.arc( 0, 0, 1, 0, PI2, true );
                context.fill();
            }
        } );
        
        for ( var ix = 0; ix < AMOUNTX; ix ++ ) {
            for ( var iy = 0; iy < AMOUNTY; iy ++ ) {
                particle = new THREE.Sprite( material );
                particle.position.x = ix * SEPARATION - ( ( AMOUNTX * SEPARATION ) / 2 );
                particle.position.y = iy * SEPARATION - ( ( AMOUNTY * SEPARATION ) / 2 );
                scene.add( particle );
            }
        }


    }

    //

    function animate() {

        requestAnimationFrame( animate );

        render();
        stats.update();

    }

    function render() {

        camera.position.x += ( mouseX - camera.position.x ) * .05;
        camera.position.y += ( - mouseY - camera.position.y ) * .05;
        camera.lookAt( scene.position );

        if (isDataReady){ //render could be called few times before json is loaded, causing errors. 
            //update dots 
            for (var i =0; i < data.nodes.length; i++){
                particles[ i ].position.x = data.nodes[i].x;
                particles[ i ].position.y = data.nodes[i].y;
                // console.log("updating: " + data.nodes[0].x ); 
            } 
            
            //update lines connecting dots 
            data.links.forEach(function(d,i){
                // debugger
                var t = particles[d.target.id];
                var s = particles[d.source.id];

                lines[i].geometry.vertices[0].x = s.position.x;
                lines[i].geometry.vertices[0].y = s.position.y;
                lines[i].geometry.vertices[0].z = s.position.z;

                lines[i].geometry.vertices[1].x = t.position.x;
                lines[i].geometry.vertices[1].y = t.position.y;
                lines[i].geometry.vertices[1].z = t.position.z;

                // lines[i].geometry.verticesNeedUpdate = true; 


            });   

           
        }
        
            



        renderer.render( scene, camera );

        // count += 0.1;

    }

</script>
 
</body>
</html>
