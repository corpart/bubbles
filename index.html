<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<title>bubbles</title>
<style>
html, body/*, #graph */{
    width: 800px;
    height: 600px;
}
.button{
    
    height: 50px;
    width: 50px;
    margin: 5px;
}

.links line {
  stroke: #999;
  stroke-opacity: 0.3;
}

#option{
    position:absolute;
    width: 800px;
    height: 900px;
    left : 0px ;
    top: 0px;
}
</style>
</head>

<body>
<div id="graph"></div>    

<script src="build/three.js"></script>    
<script src="js/renderers/Projector.js"></script>
<script src="js/renderers/CanvasRenderer.js"></script>
<script src="js/libs/stats.min.js"></script>

<script src="js/libs/d3.min.js"></script>    
<!-- <script src="js/viz.js"></script> -->


<script>

    var SEPARATION = 100, AMOUNTX = 20, AMOUNTY = 20;

    var container, stats;
    var camera, scene, renderer;

    var particles, particle, count = 0;


    var mouseX = 0, mouseY = 0;

    var windowHalfX = window.innerWidth / 2;
    var windowHalfY = window.innerHeight / 2;

    var data
    var isDataReady = false; 

    var PI2 = Math.PI * 2;

    init();
    animate();

    function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
        camera.position.z = 1000;

        scene = new THREE.Scene();

        particles = new Array();
        lines = new Array();       
      

        //load data from json  
        d3.json("data/data.json", function(error, dataset){
                if (error) {
                    console.log(error);
                }else{
                    isDataReady = true; 
                    data = dataset ;
                    prep(data);
                       
                }
        });
         

       /////base wall
        var material = new THREE.SpriteCanvasMaterial( { 
            color: 0xffffff,
            program: function ( context ) {
                context.beginPath();
                context.arc( 0, 0, 1, 0, PI2, true );
                context.fill();
            }
        } );
        
        for ( var ix = 0; ix < AMOUNTX; ix ++ ) {
            for ( var iy = 0; iy < AMOUNTY; iy ++ ) {
                particle = new THREE.Sprite( material );
                particle.position.x = ix * SEPARATION - ( ( AMOUNTX * SEPARATION ) / 2 );
                particle.position.y = iy * SEPARATION - ( ( AMOUNTY * SEPARATION ) / 2 );
                scene.add( particle );
            }
        }


        ///THREEJS 
        renderer = new THREE.CanvasRenderer();
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );

        stats = new Stats();
        container.appendChild( stats.dom );

        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        document.addEventListener( 'touchstart', onDocumentTouchStart, false );
        document.addEventListener( 'touchmove', onDocumentTouchMove, false );

        //

        window.addEventListener( 'resize', onWindowResize, false );

    }

    function prep(data){
        // console.log(data);
        var particleMaterial = new THREE.SpriteCanvasMaterial( {
            color: 0xff0000,
            program: function ( context ) {
                context.beginPath();
                context.arc( 0, 0, 10, 0, PI2, true );
                context.fill();
            }
        } );
       
        for (var i =0; i < data.nodes.length; i++){          
            particle = particles[ i ] = new THREE.Sprite( particleMaterial );
            particle.position.x = ~~d3.randomUniform(-300, 300)()//data.nodes[i].x;
            particle.position.y = ~~d3.randomUniform(-300, 300)(); //data.nodes[i].y;
            particle.position.z = ~~d3.randomUniform(-70, 70)();
            scene.add( particle );           
            // console.log("initializing THREE particles"); 
            // console.log(i+" "+ data.nodes[i].x+ " " + data.nodes[i].y);
            // console.log(i+" "+ particle.position.x + " " + particle.position.y );
        }

        var lineMaterial = new THREE.LineBasicMaterial({
            color: 0x0000ff
        });
        var geometry = new THREE.Geometry()

        data.links.forEach(function(d){
            // console.log('data link' + d.target)

            geometry.vertices.push(
                particle
            );

        })

        
        var simulation = d3.forceSimulation()
            .force("link", d3.forceLink()
                .id(function(d) { return d.index })
                .distance(function(d){return d.value})
                .strength(0.1)
                )

            .force("collide",d3.forceCollide( function(d){return d.r + 80 }).iterations(2) ) //16
            .force("charge", d3.forceManyBody(0)
                .strength(-30)  //negative:repell 
                // .distanceMax(100)
                )
            .force("center", d3.forceCenter(windowHalfX / 2, windowHalfY / 2-100)) // keeps nodes in the center of the viewport
            .force("y", d3.forceY(0))
            .force("x", d3.forceX(0).strength(0.05))

        // var ticked = function() { ///TODO function??
        // }  

        simulation
            .nodes(data.nodes)
            // .on("tick", ticked) //updates are handled by the THREE render function 
            .force("link")
            .links(data.links);

        
    }





    function onWindowResize() {

        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    //

    function onDocumentMouseMove( event ) {

        mouseX = event.clientX - windowHalfX;
        mouseY = event.clientY - windowHalfY;

    }

    function onDocumentTouchStart( event ) {

        if ( event.touches.length === 1 ) {

            event.preventDefault();

            mouseX = event.touches[ 0 ].pageX - windowHalfX;
            mouseY = event.touches[ 0 ].pageY - windowHalfY;

        }

    }

    function onDocumentTouchMove( event ) {

        if ( event.touches.length === 1 ) {

            event.preventDefault();

            mouseX = event.touches[ 0 ].pageX - windowHalfX;
            mouseY = event.touches[ 0 ].pageY - windowHalfY;

        }

    }

    //

    function animate() {

        requestAnimationFrame( animate );

        render();
        stats.update();

    }

    function render() {

        camera.position.x += ( mouseX - camera.position.x ) * .05;
        camera.position.y += ( - mouseY - camera.position.y ) * .05;
        camera.lookAt( scene.position );

        if (isDataReady){
            for (var i =0; i < data.nodes.length; i++){
                particles[ i ].position.x = data.nodes[i].x;
                particles[ i ].position.y = data.nodes[i].y;
                // console.log("updating: " + data.nodes[0].x ); 
            }    
        }
        
            



        renderer.render( scene, camera );

        count += 0.1;

    }

</script>
 
</body>
</html>
