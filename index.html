<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<title>bubbles</title>
<style>
html, body/*, #graph */{
    width: 800px;
    height: 600px;
}
.button{
    
    height: 50px;
    width: 50px;
    margin: 5px;
}

.links line {
  stroke: #999;
  stroke-opacity: 0.3;
}

svg{
    position:absolute;
    width: 800px;
    height: 900px;
    left : 0px ;
    top: 0px;
}
</style>
</head>

<body>
 

<script src="build/three.js"></script>    
<script src="js/renderers/Projector.js"></script>
<script src="js/renderers/CanvasRenderer.js"></script>
<script src="js/libs/stats.min.js"></script>

<script src="js/libs/d3.min.js"></script>    
<!-- <script src="js/viz.js"></script> -->


<script>

    var SEPARATION = 100, AMOUNTX = 20, AMOUNTY = 20;

    var container, stats;
    var camera, scene, renderer;

    var particles, particle, count = 0;
    var lines; 


    var mouseX = 0, mouseY = 0;

    var windowHalfX = window.innerWidth / 2;
    var windowHalfY = window.innerHeight / 2;

    var data
    var isDataReady = false; 
    
    var particleMaterial
    var lineMaterial

    var simulation

    var buttons 

    var svg 

    var buttonData = [
                {id: 0, label: "addBubble",  x: 10, y:500 },
                {id: 1, label: "addbubble1", x: 80, y: 500 },
                {id: 2, label: "addbubble2", x: 190, y: 500 },
                {id: 3, label: "addbubble2", x: 260, y: 500 },
                {id: 4, label: "addbubble2", x: 370, y: 500 },
                {id: 5, label: "addbubble2", x: 430, y: 500 }
                ];

    var PI2 = Math.PI * 2;

    init();
    animate();

    function init() {

        container = document.createElement( 'div' );
        container.setAttribute("z-index", 1);


        document.body.appendChild( container );

        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
        camera.position.z = 1000;

        scene = new THREE.Scene();

        particles = new Array();
        lines = new Array();    

        lineMaterial = new THREE.LineBasicMaterial({
            color: 0xaaaaaa
        });
      
        drawBackground();
        //load data from json  
        d3.json("data/data.json", function(error, dataset){
                if (error) {
                    console.log(error);
                }else{
                    isDataReady = true; 
                    data = dataset ;
                    prep(data);
                       
                }
        });
         
        drawForeground();
        ///THREEJS 
        renderer = new THREE.CanvasRenderer();
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );

        stats = new Stats();
        container.appendChild( stats.dom );

        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        document.addEventListener( 'touchstart', onDocumentTouchStart, false );
        document.addEventListener( 'touchmove', onDocumentTouchMove, false );

        //

        window.addEventListener( 'resize', onWindowResize, false );

    }

    function prep(data){
        // console.log(data);
         particleMaterial = new THREE.SpriteCanvasMaterial( {
            color: 0xff0000,
            program: function ( context ) {
                context.beginPath();
                context.arc( 0, 0, 10, 0, PI2, true );
                context.fill();
            }
        } );
       
        for (var i =0; i < data.nodes.length; i++){          
            particle = particles[ i ] = new THREE.Sprite( particleMaterial );
            particle.position.x = ~~d3.randomUniform(-300, 300)()//data.nodes[i].x;
            particle.position.y = ~~d3.randomUniform(-300, 300)(); //data.nodes[i].y;
            particle.position.z = ~~d3.randomUniform(-150, 150)();
            scene.add( particle );           
            // console.log("initializing THREE particles"); 
            // console.log(i+" "+ data.nodes[i].x+ " " + data.nodes[i].y);
            // console.log(i+" "+ particle.position.x + " " + particle.position.y );
        }
        
        data.links.forEach(function(d){
           addLineBetweenTwoParticles(d.source, d.target);
        })
          
        simulation = d3.forceSimulation()
            .force("link", d3.forceLink()
                .id(function(d) { return d.index })
                .distance(function(d){return d.value})
                .strength(0.1)
                )

            .force("collide",d3.forceCollide( function(d){  return d.r + 40 }).iterations(2) ) //16
            .force("charge", d3.forceManyBody(0)
                .strength(-30)  //negative:repell 
                .distanceMax(200)
                )
            .force("center", d3.forceCenter(windowHalfX / 2, windowHalfY / 2)) // keeps nodes in the center of the viewport
            .force("y", d3.forceY(0))
            .force("x", d3.forceX(0).strength(0.05))

        // var ticked = function() { ///TODO function?
        // }  

        simulation
            .nodes(data.nodes)
            // .on("tick", ticked) //updates are handled by the THREE render function 
            .force("link")
            .links(data.links);

        
    }

    function addLineBetweenTwoParticles(sourceInd,targetInd){
        //make sure indexes are in range
        if (sourceInd < particles.length && targetInd < particles.length){
            var newLineIndex = lines.length; 
            var geometryLine = new THREE.Geometry()
            var t = particles[targetInd];
            var s = particles[sourceInd];
            geometryLine.vertices.push(
                new THREE.Vector3( t.position.x, t.position.y, t.position.z ),
                new THREE.Vector3( s.position.x, s.position.y, s.position.z )
            );

            var lineTemp = lines[newLineIndex] = new THREE.Line(geometryLine, lineMaterial)
            scene.add(lineTemp);
            console.log("line " + newLineIndex + " added between " + sourceInd + " & " + targetInd) ; 
        }
      
    }


    function onWindowResize() {

        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    //

    function onDocumentMouseMove( event ) {

        mouseX = event.clientX - windowHalfX;
        mouseY = event.clientY - windowHalfY;

    }

    function onDocumentTouchStart( event ) {

        if ( event.touches.length === 1 ) {

            event.preventDefault();

            mouseX = event.touches[ 0 ].pageX - windowHalfX;
            mouseY = event.touches[ 0 ].pageY - windowHalfY;

        }

    }

    function onDocumentTouchMove( event ) {

        if ( event.touches.length === 1 ) {

            event.preventDefault();

            mouseX = event.touches[ 0 ].pageX - windowHalfX;
            mouseY = event.touches[ 0 ].pageY - windowHalfY;

        }

    }

    function pushBubble(bx, by, bi){
            
            var newNodeID = data.nodes.length; 
            data.nodes.push({
                id:  newNodeID, 
                r: ~~d3.randomUniform(10,60)(), 
                x:bx,
                y:by,
                group:  bi });
            
            var particle = particles[ newNodeID ] = new THREE.Sprite( particleMaterial );
            particle.position.x = bx;
            particle.position.y = by; 
            particle.position.z = ~~d3.randomUniform(-70, 70)();
            scene.add( particle );       
            // debugger
            //link to other nodes with same group 
            var sameGroup = data.nodes.filter ( 
                    function(d){ 
                    return +d.group == bi; } // +turn string to number
                )
            
            if (sameGroup.length>0){
               
                //add first link 
                var j = ~~d3.randomUniform(0, sameGroup.length)(); 
                var targetInd = sameGroup[j].id; 
                // console.log("connecting " + newID + " & " + sameGroup[j].id ); 
                data.links.push ({source: newNodeID , target: targetInd, value:1 })
                addLineBetweenTwoParticles(newNodeID, targetInd)
              

                //add second link
                j = ~~d3.randomUniform(0, sameGroup.length)(); 
                targetInd = sameGroup[j].id; 
                // console.log("connecting " + newID + " & " + sameGroup[j].id ); 
                data.links.push ({source: newNodeID , target: targetInd, value:1 })
                addLineBetweenTwoParticles(newNodeID, targetInd)



            }

            
            restart(data);
        }




        function restart(data) {
          
          // // Apply the general update pattern to the nodes.
          //   node = node.data(data.nodes, function(d) { return d.id;});
          //   node.exit().remove();
          //   node = node.enter().append("circle")
          //       .attr("r", function(d){  return d.r })
          //       .attr("fill", function(d) { return color(d.group); })
          //       // .attr("fill", function(d) { return color(~~d3.randomUniform(20)()); })
          //       .merge(node);
    
          // // Apply the general update pattern to the links.
          //   link = link.data(data.links, function(d) { return d.source.id + "-" + d.target.id; });
          //   link.exit().remove();
          //   link = link.enter().append("line").merge(link);

          // Update and restart the simulation.
            simulation.nodes(data.nodes);
            simulation.force("link").links(data.links);
            simulation.alpha(1).restart();
        }



    function drawForeground(){
         svg = d3.select('body').append('svg')
         var color = d3.scaleOrdinal(d3.schemeCategory20);     
         buttons = svg
            .selectAll("rect")
            .data(buttonData)
            .enter()
            .append("rect")
            .attr("class", "button")
            .attr("id", function(d){ return d.id;}  )
            .attr("x",function(d){return d.x} )
            .attr("y",function(d){return d.y} )
            .attr("fill", function (d,i){ return color(i); })
            .attr("startTime", undefined )
            .attr("elapsed", 0 )
            .attr("scale",1)
            .attr("touching", false)
            ; 
         
         d3.selectAll(".button")
            .on("mousedown", function(){
                console.log("mousedown on button: " + d3.select(this).attr("id") );
                //record time 
                // d3.select(this).attr("touchStartTime") = new Date().getTime();  
                
            })
            .on("mouseup", function() {
            // console.log("button clicked: " + d3.select(this).attr("id") );
            pushBubble(d3.select(this).attr("x"),d3.select(this).attr("y"), d3.select(this).attr("id"));
        })

    }



    function drawBackground(){
           /////base wall
        var material = new THREE.SpriteCanvasMaterial( { 
            color: 0xffffff,
            program: function ( context ) {
                context.beginPath();
                context.arc( 0, 0, 1, 0, PI2, true );
                context.fill();
            }
        } );
        
        for ( var ix = 0; ix < AMOUNTX; ix ++ ) {
            for ( var iy = 0; iy < AMOUNTY; iy ++ ) {
                particle = new THREE.Sprite( material );
                particle.position.x = ix * SEPARATION - ( ( AMOUNTX * SEPARATION ) / 2 );
                particle.position.y = iy * SEPARATION - ( ( AMOUNTY * SEPARATION ) / 2 );
                scene.add( particle );
            }
        }


    }

    //

    function animate() {

        requestAnimationFrame( animate );

        render();
        stats.update();

    }

    function render() {

        camera.position.x += ( mouseX - camera.position.x ) * .05;
        camera.position.y += ( - mouseY - camera.position.y ) * .05;
        camera.lookAt( scene.position );

        if (isDataReady){
            //update dots 
            for (var i =0; i < data.nodes.length; i++){
                particles[ i ].position.x = data.nodes[i].x;
                particles[ i ].position.y = data.nodes[i].y;
                // console.log("updating: " + data.nodes[0].x ); 
            } 
            
            //update lines connecting dots 
            data.links.forEach(function(d,i){
                // debugger
                var t = particles[d.target.id];
                var s = particles[d.source.id];

                lines[i].geometry.vertices[0].x = s.position.x;
                lines[i].geometry.vertices[0].y = s.position.y;
                lines[i].geometry.vertices[0].z = s.position.z;

                lines[i].geometry.vertices[1].x = t.position.x;
                lines[i].geometry.vertices[1].y = t.position.y;
                lines[i].geometry.vertices[1].z = t.position.z;

                // lines[i].geometry.verticesNeedUpdate = true; 


            });   

           
        }
        
            



        renderer.render( scene, camera );

        count += 0.1;

    }

</script>
 
</body>
</html>
